# -*- coding: utf-8 -*-
"""OpenCV_test.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sQTrdpnjweMiPrUn8h-VPgOJP6nwdmjD
"""

# OpenCV: From Basic to Advanced
# MIT License
# Reference :: https://www.kaggle.com/code/talhabu/opencv-tutorial-from-basic-to-advanced

# Loading Neccessary Libararies & Dataset
import cv2
import numpy as np
import matplotlib.pyplot as plt

# Loading the dataset
img_paths = ["/content/dog.jpg"]

# read the image using OpenCV
img = cv2.imread(img_paths[0])

# convert the color from BGR to RGB for displaying using matplotlib
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# display the image using matplotlib
plt.imshow(img)
plt.title('Dog Image')
plt.axis('off')
plt.show()

# Converting from RGB to Grayscale
# Loading the image
img = cv2.imread(img_paths[0])

# Converting the image to grayscale
gray_img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)

# Displaying the results
fig, axs = plt.subplots(1, 2, figsize=(10, 10))
axs[0].imshow(img)
axs[0].set_title('Original Image')
axs[1].imshow(gray_img, cmap='gray')
axs[1].set_title('Grayscale Image')
axs[0].axis('off')
axs[1].axis('off')
plt.show()

# Loading the image
img = cv2.imread(img_paths[0])

# Converting the image to grayscale
gray_img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)

# Displaying the results
fig, axs = plt.subplots(1, 2, figsize=(10, 10))
axs[0].imshow(img)
axs[0].set_title('Original Image')
axs[1].imshow(gray_img, cmap='gray')
axs[1].set_title('Grayscale Image')
axs[0].axis('off')
axs[1].axis('off')
plt.show()

# Load the image
img = cv2.imread(img_paths[0])
# Create a black mask with the same size as the image
mask = np.zeros_like(img)
# Define the center and radius of the circle
height, width = img.shape[:2]
center = (width // 2, height // 2)
radius = min(center[0], center[1])
# Draw a white circle in the mask
cv2.circle(mask, center, radius, (255, 255, 255), -1)
# Apply the mask to the image
masked_image = cv2.bitwise_and(img, mask)
# Display the original image with the circular mask
fig, ax = plt.subplots(1, 2, figsize=(10, 5))
ax[0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
ax[0].set_title('Original Image')
ax[1].imshow(cv2.cvtColor(masked_image, cv2.COLOR_BGR2RGB))
ax[1].set_title('Masked Image')
ax[0].axis('off')
ax[1].axis('off')
plt.show()

"""#Image Color Channel"""

# Load the image
img = cv2.imread(img_paths[0])

# Split the image into its color channels
b, g, r = cv2.split(img)

# Display each color channel as a separate image
fig, ax = plt.subplots(1, 3, figsize=(15, 8))
ax[0].imshow(b, cmap='Blues')
ax[0].set_title('Blue Channel')
ax[1].imshow(g, cmap='Greens')
ax[1].set_title('Green Channel')
ax[2].imshow(r, cmap='Reds')
ax[2].set_title('Red Channel')
ax[0].axis('off')
ax[1].axis('off')
ax[2].axis('off')
plt.show()

# Merging Images

# load an image from the dataset
img = cv2.imread(img_paths[0])

# split the image into individual color channels
b, g, r = cv2.split(img)

# merge the color channels back into an image
merged_img = cv2.merge([r, g, b])

# display the original and merged images using matplotlib
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))
ax1.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
ax1.set_title('Original Image')
ax2.imshow(cv2.cvtColor(merged_img, cv2.COLOR_BGR2RGB))
ax2.set_title('Merged Image')
ax1.axis('off')
ax2.axis('off')
plt.show()

# Grayscale Histogram
# Loading the image
img = cv2.imread(img_paths[0])

# Plotting the histogram of a grayscale image
gray_img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)

plt.hist(gray_img.ravel(), 256, [0, 256])
plt.title("Grayscale Histogram")
plt.show()

# Convert the image to grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Calculate the grayscale histogram using cv2.calcHist()
hist = cv2.calcHist([gray], [0], None, [256], [0, 256])

# Display the histogram using matplotlib
plt.plot(hist, color='gray')
plt.xlabel('Intensity Level')
plt.ylabel('Pixel Count')
plt.title('Grayscale Histogram')
plt.show()

# Color Histogram
# Plotting the histogram of a color image
color_img = cv2.imread(img_paths[0])

color = ('r', 'g', 'b')
for i, col in enumerate(color):
    hist = cv2.calcHist([color_img], [i], None, [256], [0, 256])
    plt.plot(hist, color=col)
    plt.xlim([0, 256])

plt.title("Color Histogram")
plt.show()

# Load an image from the dataset
img = cv2.imread(img_paths[0])
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# Convert the image to grayscale
gray_img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)

# Perform histogram equalization on the grayscale image
eq_gray_img = cv2.equalizeHist(gray_img)

# Plot the images and histograms
fig, axs = plt.subplots(2, 2, figsize=(10, 10))

axs[0, 0].imshow(img)
axs[0, 0].set_title('Original Image')

axs[0, 1].hist(gray_img.ravel(), 256, [0, 256])
axs[0, 1].set_title('Original Histogram')

axs[1, 0].imshow(eq_gray_img, cmap='gray')
axs[1, 0].set_title('Equalized Image')

axs[1, 1].hist(eq_gray_img.ravel(), 256, [0, 256])
axs[1, 1].set_title('Equalized Histogram')
axs[0, 0].axis('off')
axs[1, 0].axis('off')
plt.show()

# Load image from dataset
img = cv2.imread(img_paths[0])

# Create a figure to display the images
fig, axs = plt.subplots(2, 2, figsize=(10, 10))

# Display the original image
axs[0, 0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
axs[0, 0].set_title('Original Image')

# Apply a Gaussian blur to the image
gaussian_blur = cv2.GaussianBlur(img, (11, 11), 0)
axs[0, 1].imshow(cv2.cvtColor(gaussian_blur, cv2.COLOR_BGR2RGB))
axs[0, 1].set_title('Gaussian Blur')

# Apply a median blur to the image
median_blur = cv2.medianBlur(img, 7)
axs[1, 0].imshow(cv2.cvtColor(median_blur, cv2.COLOR_BGR2RGB))
axs[1, 0].set_title('Median Blur')

# Apply a bilateral filter to the image
bilateral_filter = cv2.bilateralFilter(img, 9, 75, 75)
axs[1, 1].imshow(cv2.cvtColor(bilateral_filter, cv2.COLOR_BGR2RGB))
axs[1, 1].set_title('Bilateral Filter')
axs[0, 0].axis('off')
axs[0, 1].axis('off')
axs[1, 0].axis('off')
axs[1, 1].axis('off')
plt.show()

# Load image from dataset
img = cv2.imread(img_paths[0])

# Convert image to grayscale
gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Apply thresholding using a threshold value of 127
ret, thresh = cv2.threshold(gray_img, 127, 255, cv2.THRESH_BINARY)

# Display the results
fig, axs = plt.subplots(1, 2, figsize=(10, 10))
axs[0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
axs[0].set_title("Original Image")
axs[1].imshow(thresh, cmap="gray")
axs[1].set_title("Thresholded Image")
axs[0].axis('off')
axs[1].axis('off')
plt.show()

# Reading the image
img = cv2.imread(img_paths[0])

# Converting the image to grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Computing the gradient in the x direction using the Scharr operator
sobel_x = cv2.Scharr(gray, cv2.CV_64F, 1, 0)

# Computing the gradient in the y direction using the Scharr operator
sobel_y = cv2.Scharr(gray, cv2.CV_64F, 0, 1)

# Computing the gradient magnitude
grad_mag = np.sqrt(sobel_x ** 2 + sobel_y ** 2)

# Normalizing the gradient magnitude to the range [0, 255]
grad_mag_norm = cv2.normalize(grad_mag, None, 0, 255, cv2.NORM_MINMAX, cv2.CV_8U)

# Displaying the results
fig, axs = plt.subplots(1, 2, figsize=(10, 10))
axs[0].imshow(img)
axs[0].set_title("Original Image")
axs[1].imshow(grad_mag_norm, cmap="gray")
axs[1].set_title("Gradient Magnitude")
axs[0].axis('off')
axs[1].axis('off')
plt.show()

# Read the image
img = cv2.imread(img_paths[0])

# Convert the image to grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Apply Gaussian Blur to reduce noise
blurred = cv2.GaussianBlur(gray, (5, 5), 0)

# Apply Canny Edge Detection
edges = cv2.Canny(blurred, 100, 200)

# Display the original image and the edges detected image side by side
fig, axs = plt.subplots(1, 2, figsize=(10, 10))
axs[0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
axs[0].set_title('Original Image')
axs[1].imshow(edges, cmap='gray')
axs[1].set_title('Canny Edge Detection')
axs[0].axis('off')
axs[1].axis('off')
plt.show()

# Image with Contours

# Load the image paths
img_paths = ["/content/dog.jpg"]

# Loop over the images and create contours
for img_path in img_paths:
    # Check if img_path is a string
    if isinstance(img_path, str):
        # Read the image and convert to grayscale
        img = cv2.imread(img_path)
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

        # Apply thresholding to obtain a binary image
        _, binary = cv2.threshold(gray, 50, 255, cv2.THRESH_BINARY)

        # Find the contours in the binary image
        contours, hierarchy = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

        # Draw the contours on the original image
        img_contours = cv2.drawContours(img, contours, -1, (0, 255, 0), 2)

        # Display the images
        fig, axs = plt.subplots(1, 2, figsize=(10, 5))
        axs[0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
        axs[0].set_title("Original Image")
        axs[1].imshow(cv2.cvtColor(img_contours, cv2.COLOR_BGR2RGB))
        axs[1].set_title("Image with Contours")
        axs[0].axis('off')
        axs[1].axis('off')
        plt.show()
    else:
        print(f"Invalid image path: {img_path}")

# Image Transformation
# Read the image
img_path = "/content/dog.jpg"
img = cv2.imread(img_path)

# Define the transformation matrix (e.g. rotation, translation, scaling)
M = cv2.getRotationMatrix2D((img.shape[1]/2, img.shape[0]/2), 45, 1) # 45 degree rotation with scale=1

# Apply the transformation to the image
transformed_img = cv2.warpAffine(img, M, (img.shape[1], img.shape[0]))

# Display the original and transformed images side by side
fig, axs = plt.subplots(1, 2, figsize=(10, 5))
axs[0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
axs[0].set_title("Original Image")
axs[1].imshow(cv2.cvtColor(transformed_img, cv2.COLOR_BGR2RGB))
axs[1].set_title("Transformed Image")
axs[0].axis('off')
axs[1].axis('off')
plt.show()

# Image Shifting

# Read the image
img = cv2.imread(img_path)

# Define the translation values
translationX = 50
translationY = 100

# Define the transformation matrix
modifiedImage = np.float32([[1, 0, translationX],
                            [0, 1, translationY]])

# Apply the transformation to the image
imageShift = cv2.warpAffine(img, modifiedImage,
                            (img.shape[1], img.shape[0]))

# Show the original and shifted images
fig, ax = plt.subplots(1, 2, figsize=(10, 5))
ax[0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
ax[0].set_title("Original Image")
ax[1].imshow(cv2.cvtColor(imageShift, cv2.COLOR_BGR2RGB))
ax[1].set_title("Shifted Image")
ax[0].axis('off')
ax[1].axis('off')
plt.show()

# Image Rotation

# Read the image
img = cv2.imread(img_path[0])

# Define the rotation angle in degrees and the scaling factor
angle = 80
scale = 1

# Read the image
img = cv2.imread(img_path)

# Get the dimensions of the image
height, width = img.shape[:2]

# Calculate the rotation matrix
rotation_matrix = cv2.getRotationMatrix2D((width/2, height/2), angle, scale)

# Apply the rotation to the image
rotated_img = cv2.warpAffine(img, rotation_matrix, (width, height))

# Display the original and rotated images
fig, axs = plt.subplots(1, 2, figsize=(10, 5))
axs[0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
axs[0].set_title("Original Image")
axs[1].imshow(cv2.cvtColor(rotated_img, cv2.COLOR_BGR2RGB))
axs[1].set_title("Rotate Image")
axs[0].axis('off')
axs[1].axis('off')
plt.show()

# Image Resizing

# Define the new dimensions for the resized image
new_width = 500
new_height = 500

# Read the image
img = cv2.imread(img_path)

# Get the original dimensions of the image
height, width, _ = img.shape

# Calculate the scale factor for resizing
scale_x = new_width / width
scale_y = new_height / height

# Resize the image
resized_img = cv2.resize(img, (new_width, new_height))

# Display the original and rotated images
fig, axs = plt.subplots(1, 2, figsize=(10, 5))
axs[0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
axs[0].set_title("Original Image")
axs[1].imshow(cv2.cvtColor(resized_img, cv2.COLOR_BGR2RGB))
axs[1].set_title("Resized Image")
axs[0].axis('off')
axs[1].axis('off')
plt.show()

# Image Flippping

# Loop over the images and flip them horizontally
img = cv2.imread(img_path)

    # Flip the image horizontally using cv2.flip()
flipped_img = cv2.flip(img, 1)

    # Display the original and flipped images side by side using matplotlib
fig = plt.figure(figsize=(10, 5))
plt.subplot(1,2,1)
plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
plt.title('Original')
plt.xticks([]), plt.yticks([])

plt.subplot(1,2,2)
plt.imshow(cv2.cvtColor(flipped_img, cv2.COLOR_BGR2RGB))
plt.title('Flipped')
plt.xticks([]), plt.yticks([])
plt.axis('off')
plt.show()

# Image Cropping
# Read the image
img = cv2.imread(img_path)

# Define the coordinates of the top left and bottom right corners of the crop
x1, y1, x2, y2 = 100, 100, 400, 400

# Crop the image
cropped_img = img[y1:y2, x1:x2]

# Show the original and cropped images side by side
fig, ax = plt.subplots(1, 2, figsize=(10, 5))
ax[0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
ax[0].set_title("Original Image")
ax[1].imshow(cv2.cvtColor(cropped_img, cv2.COLOR_BGR2RGB))
ax[1].set_title("Cropped Image")
ax[0].axis('off')
ax[1].axis('off')
plt.show()

# Morphological Operations
img_path = "/content/dog.jpg"

# Read the image
img = cv2.imread(img_path)

# Convert the image to grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Apply binary thresholding to obtain a binary image
ret, binary = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)

# Define the structuring element
kernel = np.ones((5,5), np.uint8)

# Apply dilation to the binary image
dilation = cv2.dilate(binary, kernel, iterations=1)

# Apply erosion to the binary image
erosion = cv2.erode(binary, kernel, iterations=1)

# Apply opening to the binary image
opening = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel)

# Apply closing to the binary image
closing = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)

# Display the original image and processed images using matplotlib
fig = plt.figure(figsize=(6, 6))
plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
plt.title('Original Image')
plt.axis('off')
plt.show()

plt.imshow(binary, cmap='gray')
plt.title('Binary Image')
plt.axis('off')
plt.show()

plt.imshow(dilation, cmap='gray')
plt.title('Dialation Image')
plt.axis('off')
plt.show()

plt.imshow(erosion, cmap='gray')
plt.title('Erosion Image')
plt.axis('off')
plt.show()

plt.imshow(opening, cmap='gray')
plt.title('Opening Image')
plt.axis('off')
plt.show()

plt.imshow(closing, cmap='gray')
plt.title('Closing Image')
plt.axis('off')
plt.show()

# Image Bitwise Logical Operations
# Read in the image
img = cv2.imread(img_path)

# Create a mask (in this case, just a simple rectangle)
mask = np.zeros(img.shape[:2], dtype=np.uint8)
cv2.rectangle(mask, (100, 100), (300, 300), (255, 255, 255), -1)

# Perform a bitwise AND operation between the image and the mask
masked_image = cv2.bitwise_and(img, img, mask=mask)

# Perform a bitwise OR operation between the image and the mask
masked_image2 = cv2.bitwise_or(img, img, mask=mask)

# Perform a bitwise XOR operation between the image and the mask
masked_image3 = cv2.bitwise_xor(img, img, mask=mask)

# Perform a bitwise NOT operation on the mask
mask_inv = cv2.bitwise_not(mask)

# Perform a bitwise AND operation between the image and the inverted mask
masked_image4 = cv2.bitwise_and(img, img, mask=mask_inv)

# Display the results using matplotlib
plt.figure(figsize=(15,15))
plt.subplot(231)
plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
plt.title('Original Image')
plt.axis('off')

plt.subplot(232)
plt.imshow(cv2.cvtColor(masked_image, cv2.COLOR_BGR2RGB))
plt.title('Bitwise AND')
plt.axis('off')

plt.subplot(233)
plt.imshow(cv2.cvtColor(masked_image2, cv2.COLOR_BGR2RGB))
plt.title('Bitwise OR')
plt.axis('off')

plt.subplot(234)
plt.imshow(cv2.cvtColor(masked_image3, cv2.COLOR_BGR2RGB))
plt.title('Bitwise XOR')
plt.axis('off')

plt.subplot(235)
plt.imshow(cv2.cvtColor(mask_inv, cv2.COLOR_BGR2RGB))
plt.title('Inverted Mask')
plt.axis('off')

plt.subplot(236)
plt.imshow(cv2.cvtColor(masked_image4, cv2.COLOR_BGR2RGB))
plt.title('Bitwise AND with Inverted Mask')
plt.axis('off')

plt.tight_layout()
plt.show()